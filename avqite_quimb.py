"""
This module performs VQITE simulations using tensor-network (TN) methods.
Quimb is the library for performing TN contractions.
Cotengra library is used to find optimal contraction paths.
Examples of calculations are given in the accompanying notebooks 
avqite_tn.ipynb and avqite_tn_timing_test.ipynb.

Packages information:
---------------------
NumPy version = 1.24.4
SciPy version = 1.12.0
Quimb version = 1.8.4 (errors can occur for the version 1.9.0)
Cotengra version = 0.6.2
Autoray version = 0.7.0
"""

import numpy as np
import scipy
import pickle
import time
from tqdm import tqdm
from typing import (
    List,
    Optional,
    Tuple,
    Union
)
import random

import quimb as qu
import quimb.tensor as qtn

import cotengra as ctg

class model_H:
    """
    Class for Hamiltonians constructed using incar_file.

    Attributes:
    -----------
    incar_file : str
        Incar file (of the AVQITE format).
    paulis : List[str]
        List of the Pauli strings comprising the Hamiltonian.
    coefs : List[float]
        List of the coefficients in the Hamiltonian corresponding to the Pauli
        strings in paulis.
    """
    def __init__(
        self,
        incar_file: str
    ):
        self.incar_file = incar_file
        with open(self.incar_file) as fp:
            incar_content = fp.read()
        h_pos = incar_content.find("h")
        pool_pos = incar_content.find("pool")
        h_string = incar_content[h_pos+14:pool_pos-14]

        self.paulis = "".join([el for el in h_string if el=='I' or el=='X'
                            or el=='Y' or el=='Z' or el == '\n']).split('\n')
        coefs_str = "".join([el for el in h_string if el.isdigit() or el=="-"
                            or el=="." or el == "*"]).split('*')
        self.coefs = [float(el) for el in coefs_str[0:-1]]


class Quimb_vqite:
    """
    Class for performing VQITE simualtions using Quimb.
    Form of the ansatz is read out from a file generated by AVQITE.

    Attributes:
    -----------
    _filename : str
        Filename of the incar file to read the Hamiltonian from.
    _num_qubits : int
        Number of qubits in the system. Determined from the incar file.
    _ansatz : List[str]
        Ansatz form. Obtained from the file generated by AVQITE.
    _params_solution : List[float]
        Parameters of the ansatz calculated by AVQITE. These are not updated
        throughout this calculation.
    _params : List[float]
        Parameters of the ansatz. These are updated throughout this calculation.
        Initial guess is random.
    _m : numpy.ndarray
        M matrix used in VQITE.
    _m_width : numpy.ndarray
        Contraction width matrix for the M matrix.
    _m_cost : numpy.ndarray
        Contraction cost matrix for the M matrix.
    _v : numpy.ndarray
        V vector used in VQITE.
    _ref_state : str
        Reference state. Read out from the incar file.
    _init_qc : quimb.tensor.circuit.Circuit
        Initial quantum circuit that incorporates the possible reference state
        gates.
    _pauli_rot_gates_list : List[quimb.tensor.circuit.Gate]
        List of Quimb gates representing Pauli rotations in the ansatz.
    _pauli_rot_dag_gates_list : List[quimb.tensor.circuit.Gate]
        List of Quimb gates representing inverse Pauli rotations in the ansatz.
    _base_circuits : List[quimb.tensor.circuit.Circuit]
        List of quantum circuits representing the ansatz up to ith rotation,
        where i is the index in the list.
    opt_dict : dict
        Dictionary of TN contraction paths for calculating expectation value
        of each pauli for the ansatz state.
    """
    def __init__(
        self,
        filename: str,
    ):
        self._filename = filename

        #Reads out the Hamiltonian from the incar file.
        #The number of qubits is determined from there.
        self._H = model_H("adaptvqite/adaptvqite/incars/incar"+self._filename)
        self._num_qubits = len(self._H.paulis[0])

        #Reads out the form of the ansatz and the parameters of the ansatz from
        #the ansatz file.
        #The ansatz file should be in the AVQITE format.
        (self._ansatz,
         self._params_solution) = read_adaptvqite_ansatz(
                                    "adaptvqite/adaptvqite/data/ansatz_inp.pkle"
                                    )
        #For the purposes of VQITE, we set the initial parameters to be random.
        self._params = [random.uniform(-0.1, 0.1)
                                    for i in range(len(self._params_solution))]

        self._m = np.zeros((len(self._ansatz),len(self._ansatz)))
        self._m_width = np.zeros((len(self._ansatz),len(self._ansatz)))
        self._m_cost = np.zeros((len(self._ansatz),len(self._ansatz)))

        self._v = np.zeros(len(self._ansatz))

        #Reads out the incar file.
        with open("adaptvqite/adaptvqite/incars/incar"+self._filename) as fp:
            incar_content = fp.read()
        ref_st_r_pos = incar_content.find("ref_state")
        #Reads out the reference state from the incar file.
        self._ref_state = incar_content[
                            ref_st_r_pos+13:ref_st_r_pos+13+self._num_qubits
                            ]

        #Initializes a quantum circuit.
        self._init_qc = qtn.Circuit(N=self._num_qubits)
        #If the reference state contains "1"s, adds corresponding bit-flips.
        if all([(el=='0') or (el=='1') for el in self._ref_state]):
            [self._init_qc.apply_gate('X',i)
                            for i,el in enumerate(self._ref_state) if el=='1']
        else:
            raise ValueError(
                "Reference state is supposed to be a string of 0s and 1s"
            )

        self._pauli_rot_gates_list = [
            add_pauli_rotation_gate(
                qc=qtn.Circuit(N=self._num_qubits),
                pauli_string=self._ansatz[i],
                theta=self._params[i],
                decompose_rzz=False
                ).gates for i in range(len(self._ansatz))
            ]

        self._pauli_rot_dag_gates_list = [
            add_pauli_rotation_gate(
                qc=qtn.Circuit(N=self._num_qubits),
                pauli_string=self._ansatz[i],
                theta=-self._params[i],decompose_rzz=False
                ).gates for i in range(len(self._ansatz))
            ]

        self._base_circuits = [self.circuit_2(mu)
                                    for mu in range(len(self._ansatz)+1)]


    def contruct_opt_dict(
        self,
        opt="greedy",
        simp=""
    ):
        self.h_terms_find_contractions(
            opt='greedy',
            simp=simp
        )
        self.opt_dict = dict()
        for pauli_str in self._H.paulis:
            self.opt_dict[pauli_str] = self.h_terms_reh_dict[
                pauli_str
            ]['tree'].copy()


    def compute_m(self,
                  opt='greedy',
                  simp = '',
                  backend=None,
                  which_nonzero=None
                 ):
        if which_nonzero==None:
            for nu in range(len(self._ansatz)):
                for mu in range(nu+1):
                    contr_mu_nu=self.avqite_contr1_est(
                        mu = mu,
                        nu = nu,
                        opt=opt,
                        simp=simp,
                        backend = backend
                    )
                    self._m[mu,nu] = (
                        contr_mu_nu[-1] +
                        self.avqite_contr2_est(
                            mu = mu,
                            opt=opt,
                            simp=simp,
                            backend = backend
                        )[-1]*
                        self.avqite_contr2_est(
                            mu = nu,
                            opt=opt,
                            simp=simp,
                            backend = backend
                        )[-1]
                    )
                    self._m[nu,mu] = self._m[mu,nu]
                    (self._m_width[mu,nu],
                    self._m_cost[mu,nu]) = (contr_mu_nu[0],contr_mu_nu[1])
                    self._m_width[nu,mu] = self._m_width[mu,nu]
                    self._m_cost[nu,mu] = self._m_cost[mu,nu]
        else:
            self._m = np.zeros((len(self._ansatz),len(self._ansatz)))
            for mu,nu in which_nonzero:
                contr_mu_nu=self.avqite_contr1_est(
                    mu = mu,
                    nu = nu,
                    opt=opt,
                    simp=simp,
                    backend = backend
                )
                self._m[mu,nu] = (
                    contr_mu_nu[-1] +
                    self.avqite_contr2_est(
                        mu = mu,
                        opt=opt,
                        simp=simp,
                        backend = backend
                    )[-1]*
                    self.avqite_contr2_est(
                        mu = nu,
                        opt=opt,
                        simp=simp,
                        backend = backend
                    )[-1]
                )
                self._m[nu,mu] = self._m[mu,nu]
                (self._m_width[mu,nu],
                self._m_cost[mu,nu]) = (contr_mu_nu[0],contr_mu_nu[1])
                self._m_width[nu,mu] = self._m_width[mu,nu]
                self._m_cost[nu,mu] = self._m_cost[mu,nu]


    def compute_v(self,
                  opt='greedy',
                  simp = '',
                  backend=None
                 ):
        for mu in range(len(self._params)):
            params1 = self._params.copy()
            params1[mu] = params1[mu]+np.pi/2
            params2 = self._params.copy()
            params2[mu] = params2[mu]-np.pi/2
            self._v[mu] = np.real(-1/2*(
                self.h_exp_val(
                    params = params1,
                    opt = opt,
                    simp=simp,
                    backend = backend
                ) -
                self.h_exp_val(
                    params = params2,
                    opt = opt,
                    simp=simp,
                    backend = backend)
            ) / 2 )


    def get_dthdt(self,delta, m, v):
        a = m + delta*np.eye(m.shape[0])
        ainv = np.linalg.inv(a)
        dthdt = ainv.dot(v)
        return dthdt


    def vqite(self,
              opt='greedy',
              simp = '',
              backend = None
             ):
        _iter=0
        while True:
            t1 = time.time()
            if _iter==0:
                self.compute_m(
                    opt=opt,
                    simp=simp,
                    backend = backend,
                    which_nonzero=None
                )
                non_zero_els = np.where((np.abs(self._m)>1e-14) == True)
                self.which_nonzero = [(non_zero_els[0][i],non_zero_els[1][i])
                                    for i in range(len(non_zero_els[0]))
                                    if non_zero_els[0][i]<=non_zero_els[1][i]]
            else:
                self.compute_m(
                    opt=opt,
                    simp=simp,
                    backend = backend,
                    which_nonzero=self.which_nonzero
                )
            t2 = time.time()
            self.compute_v(opt=opt,simp=simp,backend = backend)
            t3 = time.time()
            dthdt = self.get_dthdt(delta = 1e-4, m = self._m, v= self._v)
            dt = 0.02
            params_new = [p + pp*dt for p, pp in zip(self._params, dthdt)]
            self._params = params_new
            self._e = self.h_exp_val(
                params = self._params,
                opt = opt,
                simp=simp,
                backend = backend
            )
            print(
                "iter: ",_iter,
                ", M matrix time: ", t2-t1,
                ", V vector time: ", t3-t2,
                ", Energy: ", self._e
            )
            self._vmax = np.max(np.abs(self._v))
            if self._vmax < 1e-4:
                break
            _iter+=1


    def h_terms_find_contractions(
        self,
        opt='greedy',
        simp=''
    ):
        self.h_terms_reh_dict = dict()
        qc = self._base_circuits[-1].copy()
        for pauli_str in self._H.paulis:
            self.h_terms_reh_dict[pauli_str] = p_str_exp_contr_path(
                qc = qc,
                pauli_str = pauli_str,
                opt = opt,
                simp=simp
            )


    def h_exp_val(
        self,
        params = None,
        opt = 'greedy',
        simp='',
        backend = None
    ):
        qc = self._base_circuits[-1].copy()

        if params != None:
            old_params_dict = qc.get_params()
            new_params_dict = dict()
            for i,key in enumerate(old_params_dict.keys()):
                new_params_dict[key]= np.array([params[i]])
            qc.set_params(new_params_dict)

        h_exp_vals = []
        for pauli_str in self._H.paulis:
            if type(opt) == dict:
                exp_val = p_str_exp_eval(
                    qc=qc,
                    pauli_str=pauli_str,
                    opt = opt[pauli_str],
                    simp=simp,
                    backend = backend
                )
                h_exp_vals.append(exp_val)
            else:
                h_exp_vals.append( p_str_exp_eval(
                    qc=qc,
                    pauli_str=pauli_str,
                    opt = opt,
                    simp=simp,
                    backend = backend
                ) )
        exp_value = sum([h_exp_vals[i]*self._H.coefs[i]
                                    for i in range(len(self._H.coefs))])

        return exp_value


    def circuit_1(
        self,
        mu: int,
        nu: int,
        A_mu: Union["Instruction", "Operator"],
        A_nu: Union["Instruction", "Operator"]
    ):
        if mu >= nu:
            raise ValueError("Here mu<nu is required.")
        if mu > len(self._ansatz) or nu > len(self._ansatz):
            raise ValueError("mu, nu has to be smaller than "
                                "the number of operators in the ansatz")

        qc = self._base_circuits[mu].copy()
        qc.apply_gates(
            pauli_string_to_quimb_gates(pauli_string=A_mu),
            contract=False
        )
        for i in range(mu,nu):
             qc.apply_gates(self._pauli_rot_gates_list[i], contract=False)
        qc.apply_gates(
            pauli_string_to_quimb_gates(pauli_string=A_nu),
            contract=False
        )
        for i in reversed(range(nu)):
            qc.apply_gates(self._pauli_rot_dag_gates_list[i], contract=False)
        return qc


    def circuit_2(
        self,
        mu: int
    ):
        qc = self._init_qc.copy()
        for i in range(mu):
            qc.apply_gates(self._pauli_rot_gates_list[i], contract=False)
        return qc


    def avqite_contr1_est(
        self,
        mu: int,
        nu: int,
        opt = 'greedy',
        simp = '',
        backend = None
    ):
        if mu > len(self._ansatz) or nu > len(self._ansatz):
            raise ValueError("mu, nu has to be smaller than "
                                "the number of operators in the ansatz")
        if mu>nu:
            raise ValueError("it is assumed here that mu<=nu")
        if mu<nu:
            qc = self.circuit_1(
                mu,
                nu,
                A_mu = self._ansatz[mu],
                A_nu = self._ansatz[nu]
            )
            reh = qc.amplitude_rehearse(
                '0'*self._num_qubits,
                optimize=opt,
                simplify_sequence=simp
            )
            width, cost = reh['W'], reh['C']
            contraction = reh['tn'].contract(
                all,
                optimize=reh['tree'],
                output_inds=(),
                backend=backend
            )
        if mu==nu:
            width, cost, contraction = (1,0,1)
        contraction = np.real(contraction)/4
        return width, cost, contraction


    def avqite_contr2_est(
        self,
        mu: int,
        opt = 'greedy',
        simp='',
        backend = None
    ):
        if mu > len(self._ansatz):
            raise ValueError("mu has to be smaller than "
                                "the number of operators in the ansatz")
        qc = self._base_circuits[mu]
        reh = p_str_exp_contr_path(
            qc = qc,
            pauli_str = self._ansatz[mu],
            opt = opt,
            simp=simp
        )
        contraction = reh['tn'].contract(
            all,
            optimize=reh['tree'],
            output_inds=(),
            backend=backend
        )
        contraction = np.real(1j*contraction/2)
        return reh['W'], reh['C'], contraction


def add_pauli_rotation_gate(
    qc: "quimb.tensor.circuit.Circuit",
    pauli_string: str,
    theta: float,
    decompose_rzz: bool = True
):
    """
    Appends a Pauli rotation gate to a Quimb Circuit.
    Convention for Pauli string ordering is opposite to the Qiskit convention.
    For example, in string "XYZ" Pauli "X" acts on the first qubit.

    Parameters
    ----------
    qc : "quimb.tensor.circuit.Circuit"
        Quimb Circuit to which the Pauli rotation gate is appended.
    pauli_string : str
        Pauli string defining the rotation.
    theta : float
        Rotation angle.
    decompose_rzz : bool
        If decompose_rzz==True, all rzz gates are decompsed into cx-rz-cx.
        Otherwise, the final circuit contains rzz gates.

    Returns
    -------
    qc: Parameterized "quimb.tensor.circuit.Circuit"
    """

    if qc.N != len(pauli_string):
        raise ValueError("Circuit and Pauli string are of different size")
    if all([pauli=='I' or pauli=='X' or pauli=='Y' or pauli=='Z'
            for pauli in pauli_string])==False:
        raise ValueError("Pauli string does not have a correct format")

    nontriv_pauli_list = [(i,pauli)
                        for i,pauli in enumerate(pauli_string) if pauli!='I']
    if len(nontriv_pauli_list)==1:
        if nontriv_pauli_list[0][1]=='X':
            qc.apply_gate(
                'RX',
                theta,
                nontriv_pauli_list[0][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
        if nontriv_pauli_list[0][1]=='Y':
            qc.apply_gate(
                'RY',
                theta,
                nontriv_pauli_list[0][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
        if nontriv_pauli_list[0][1]=='Z':
            qc.apply_gate(
                'RZ',
                theta,
                nontriv_pauli_list[0][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
    elif (len(nontriv_pauli_list)==2 and
                    nontriv_pauli_list[0][1]+nontriv_pauli_list[1][1] == 'XX'):
            qc.apply_gate(
                'RXX',
                theta,
                nontriv_pauli_list[0][0],
                nontriv_pauli_list[1][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
    elif (len(nontriv_pauli_list)==2 and
                    nontriv_pauli_list[0][1]+nontriv_pauli_list[1][1] == 'YY'):
            qc.apply_gate(
                'RYY',
                theta,
                nontriv_pauli_list[0][0],
                nontriv_pauli_list[1][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
    else:
        for (i,pauli) in nontriv_pauli_list:
            if pauli=='X':
                qc.apply_gate('H',i)
            if pauli=='Y':
                qc.apply_gate('SDG',i)
                qc.apply_gate('H',i)
        for list_ind in range(len(nontriv_pauli_list)-2):
            qc.apply_gate(
                'CX',
                nontriv_pauli_list[list_ind][0],
                nontriv_pauli_list[list_ind+1][0]
            )
        if decompose_rzz==True:
            qc.apply_gate(
                'CX',
                nontriv_pauli_list[len(nontriv_pauli_list)-2][0],
                nontriv_pauli_list[len(nontriv_pauli_list)-1][0]
            )
            qc.apply_gate(
                'RZ',
                theta,
                nontriv_pauli_list[len(nontriv_pauli_list)-1][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
            qc.apply_gate(
                'CX',
                nontriv_pauli_list[len(nontriv_pauli_list)-2][0],
                nontriv_pauli_list[len(nontriv_pauli_list)-1][0]
            )
        if decompose_rzz==False:
            qc.apply_gate(
                'RZZ',
                theta,
                nontriv_pauli_list[len(nontriv_pauli_list)-2][0],
                nontriv_pauli_list[len(nontriv_pauli_list)-1][0],
                parametrize=True,
                gate_opts={'contract': False}
            )
        for list_ind in reversed(range(len(nontriv_pauli_list)-2)):
            qc.apply_gate(
                'CX',
                nontriv_pauli_list[list_ind][0],
                nontriv_pauli_list[list_ind+1][0]
            )
        for (i,pauli) in nontriv_pauli_list:
            if pauli=='X':
                qc.apply_gate('H',i)
            if pauli=='Y':
                qc.apply_gate('H',i)
                qc.apply_gate('S',i)
    return qc


def read_adaptvqite_ansatz(
    filename: str
):
    """
    Reads the ansatz from a file resulting from adaptvqite calculation.

    Parameters
    ----------
    filename : str
        Name of a file containing the results of adaptvqite calculation.
        Has to be given in .pkle format.

    Returns
    -------
    ansatz_adaptvqite : List[str]
        List of Pauli strings entering the ansatz.
    params_adaptvqite : List[float64]
        Parameters (angles) of the ansatz.
    """
    if filename[-5:] != '.pkle':
        raise ImportError("Ansatz file should be given in .pkle format")

    with open(filename, 'rb') as inp:
        data_inp = pickle.load(inp)
        ansatz_adaptvqite = data_inp[0]
        params_adaptvqite = data_inp[1]
        # params_adaptvqite = list(np.random.random(20))

    return ansatz_adaptvqite, params_adaptvqite


def pauli_string_to_quimb_gates(
    pauli_string
):
    """
    Converts a Pauli string into a Quimb gate.
    """
    gates = ()
    for i,el in enumerate(pauli_string):
        if el=='X':
            gates = gates + (qtn.circuit.Gate(
                label='X',
                params=[],
                qubits=(i,)
            ),)
        if el=='Y':
            gates = gates + (qtn.circuit.Gate(
                label='Y',
                params=[],
                qubits=(i,)
            ),)
        if el=='Z':
            gates = gates + (qtn.circuit.Gate(
                label='Z',
                params=[],
                qubits=(i,)
            ),)
    return gates


def p_str_exp_contr_path(
    qc,
    pauli_str: str,
    opt = 'greedy',
    simp = ''
):
    """
    Constucts a contraction path for a TN evaluating the expectation value of a
    Pauli string.

    Parameters:
    -----------
    qc : quimb.tensor.circuit.Circuit
        Quantum circuit representing a state for which the expectation value
        is computed.
    pauli_str : str
        Pauli string representing an observable.
    opt : str
        Optimizer to use when looking for a contraction path.
    simp : str
        TN simplifications to use when looking for a contraction path.

    Returns:
    --------
    reh : dict
        Dictionary representing the cotraction path and the TN to be contracted:
        reh['tree'] -- contraction path
        reh['tn'] -- TN
    """
    where = [i for i,p in enumerate(pauli_str) if p!= 'I']
    paulis = [p for i,p in enumerate(pauli_str) if p!= 'I']
    operator = qu.pauli(paulis[0])
    for i in range(1,len(where)):
        operator = operator & qu.pauli(paulis[i])
    reh = qc.local_expectation_rehearse(
        operator,
        where,
        optimize=opt,
        simplify_sequence=simp
    )
    return reh


def p_str_exp_eval(
    qc,
    pauli_str: str,
    opt = 'greedy',
    simp = '',
    backend = None,
):
    """
    Evaluates the expectation value of a Pauli string using TN contraction.

    Parameters:
    -----------
    qc : quimb.tensor.circuit.Circuit
        Quantum circuit representing a state for which the expectation value
        is computed.
    pauli_str : str
        Pauli string representing an observable.
    opt : str
        Optimizer to use when looking for a contraction path.
    simp : str
        TN simplifications to use when looking for a contraction path.
    backend : str
        Backend to use when performing the contractions.
        Usually specified if GPU acceleration is needed.
    """
    where = [i for i,p in enumerate(pauli_str) if p!= 'I']
    paulis = [p for i,p in enumerate(pauli_str) if p!= 'I']
    operator = qu.pauli(paulis[0])
    for i in range(1,len(where)):
        operator = operator & qu.pauli(paulis[i])
    exp_val = qc.local_expectation(
        operator,
        where,
        optimize=opt,
        simplify_sequence=simp,
        backend=backend
    )
    return exp_val
